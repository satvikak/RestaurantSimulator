[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=10870110&assignment_repo_type=AssignmentRepo)

# Restaurant Simulator 
 > Authors: [Suhani Bhanvadia](https://github.com/suhanihb), [Suhani Chaudhary](https://github.com/suhanic44), [Satvi Kammula](https://github.com/Satvi-Kammula), [Vaneesha Singh](https://github.com/vsingh9)

## Project Overview
**General Description:**

This project is a terminal-based restaurant simulator game. The user gets to experience being in the shoes of various roles in a restaurant and perform the respective day to day tasks for each character. The three major roles that this game will take the user through are the Manager, the Server, and the Chef. The user starts off as the Manager where they conduct the initial setup of the restaurant and the creation of a menu. The user then transitions to become the Server, where a visual floor plan is displayed to assist the Server in seating their customers at an open table. After the group is seated, the Server takes the order for their customers. A random generator is used to randomly assign items from the menu as orders for each customer. Then, the user transitions into the Chef, who is responsible for “cooking” the orders they received from the Server. Once the orders have been cooked, the user transitions back into the Server to deliver each customer their appropriate meal. After the customer has finished dining, they pay their bill and leave a rating of their experience. The game concludes with an evaluation of the restaurant’s overall balance and rating, which if exceeds a certain criteria, allows the user to play another cycle of the game.
 
**Why It's Important:**

This project is important for our group because we have all grown up playing role-playing computer games similar to this. The idea of being able to code a terminal-based game using the skills we currently possess piqued our interest, encouraging us to formulate a project that others could find entertaining as well. In addition, since some of the members in our group have experience with working in the food industry, we aimed to put the user in the shoes of various employees to demonstrate the complexity of completing such tasks. We hope this game can illustrate to the user that many different roles and responsibilities are involved behind the scenes in the actual day to day functioning of a restaurant.
 
**Languages/Tools/Technologies:**
* C++ - The backend of our project will be entirely programmed using C++.

* Visual Studio Code - This is the code editor we will be using to develop and test our code.

* Git - This is the version control system we will be using in our project to coordinate working with multiple users. Using Git allows us to seamlessly develop, commit, and push changes from our local repository. It also lets us submit pull requests to approve code changes made by other members.

* GitHub - This web-based hosting service goes hand-in-hand with Git. Current and past versions of our code can be viewed here. GitHub will also store the Kanban Board used by our team to keep track of who completes what tasks and the current status of each task.

* CMake - This is a tool we implemented to compile our code into executables that easily run our program and unit tests.

* Google Test Framework - This C++ testing framework made by Google allows us to write and run unit tests for the different functions in our code. Such testing will ensure that our program runs as expected and handles edge cases appropriately.

* Valgrind - This is a dynamic analysis tool to manage memory used by the program and keep track of any memory leaks or errors with memory allocation. This tool will ensure we have properly deleted all memory at the end of the program’s lifetime.

**Input/Output:**
* Input - As the manager, the user will be able to enter a name for the restaurant, add items to the menu (item type, item name, and item price), and change the price of items on the menu. As the server, the user will be able to enter a table number to seat a group of customers, take orders, serve customers, and collect payments. As the chef, the user will be able to receive a list of pending orders, prepare orders, and mark them as completed.
* Output - The program will display various forms of output as the user enters information into the game. As the manager, the user will be able to view the full restaurant menu once they have added items to it. As the server, the user can see a visual display of the floor plan representing seats at the restaurant. As the chef, the user can view what items have been ordered by the customer. At the end of the game, the user can view the overall rating and balance of the restaurant.

## Class Diagram
![Restaurant Class UML Diagram](https://github.com/cs100/final-project-skamm006-sbhan020-schau062-vsing035/assets/129975596/c8a664e4-e502-4547-9621-2d38fea9f4c3)

 * The Restaurant class is responsible for setting up the name of the restaurant. It contains a lot of the main functionality that different classes will need access to. The balance function will be increased every time the Customer pays their bill, and decreased anytime the Chef cooks meals incorrectly or the Server serves meals to the wrong customers. The rating will be received from the Customer, which will be evaluated at the end of each cycle to determine whether the game can continue or not. The menu will be stored in the Restaurant class, where the Manager has access to adding or deleting items from the menu. The menu will also be used by the Server and Customer classes to display and view the menu, respectively. An  additional aspect of the Restaurant class is the floorPlan. This will be implemented through a 2d array which will contain pointers to table objects. The method for the floorPlan will be protected, which allows all the employees to have access to it, including the server. The purpose of the floorPlan is to allow the server to seat the customers at an open table and keep track of which tables are occupied. Each table in the floorPlan will be given a number which will be used to keep track of which orders are from which groups of customers.
 
 * The Table class will be utilized by the Restaurant class, the Server class, and the Manager class. Each “Table” will consist of a certain number of customers, an occupied status, as well as the order list from the table. This occupation information will be utilized by the Manager class and Server class when designing a floor plan and initially seating the customers at a table. The server class will further implement the functionality of this class when taking the customers’ orders and calculating the payment required for the Restaurant. Overall, this class will merely be used for organizational purposes, and will be pivotal in deciding the reviews that the customers submit to the Restaurant.
 
 * The Customer class is the main competition that the user faces in the game. It will be implemented as a robot with randomly generated values and reviews, mocking how a real customer would behave in a restaurant. The randomly generated values represent the order they would want from the menu, while a randomly generated review (between 1-5), will be generated based on the service from the employees. For instance, a customer’s review may be generated as a higher or lower value based on seating availability, accurate customer order, and accurate food preparation. The customer will be a completely randomized, behind-the-scenes development, where the user is in charge of pleasing them through the means of the restaurant’s employees. The Customer class will also be utilized by the Table class in terms of group orders and group placement.
 
 * The Employee class serves as a base class for the Server, Chef, and Manager classes. This class includes a basic setter and getter for the employee’s name. A virtual function to print the employee’s information has been created to be overridden by the derived classes, since the server, chef, and manager will each have their own information.
 
 * The Manager Class is responsible for the beginning of the game involving the setup of the restaurant. The manager role is the person who names the restaurant and creates the menu for the customers. The manager can add and delete recipes, as well as edit the ingredients for each recipe. When the user is acting as the manager, they also give the restaurant and prepare everything for the server to start taking orders. The Manager class inherits from the Employee class, which means that each manager object will have a name, as well as access to the floor plan of the restaurant.
 
 * In the Server class, the player will be given tasks to seat the customer, display the menu, and take orders. To seat the customer, they will have access to the data already in the restaurant’s floorplan to select a suitable table in the floorplan to place the customer at. Therefore, the Server class will aggregate the group size from the customer class and make changes to the restaurant class. Next, they will print the Restaurant class’s menu list. Using the data in the menu, the player will input a string of numbers to replicate taking the customers order. The player will then play as the chef and return to the Server class to input the correct numbers again to replicate serving the customers. The Server class inherits from the Employee class, which means that each server object will have a name, as well as access to data in a table object and the restaurant’s menu list.
 
 * The Chef class is responsible for using the list of orders from the table to “make orders” and remove them from the table’s list of orders. In order to use the list of orders, the Chef class will access the data in a table object in the Restaurant class’s floor plan. To make orders, the player will be prompted to input various strings representing the recipe. Once they’ve successfully completed the task, the order will be automatically removed from the list of orders. The Chef class inherits from the Employee class, which means that each chef object will have a name, as well as access to data in a table object and the restaurant’s menu list.

### Navigation Diagram
![Navigation Diagram drawio](https://user-images.githubusercontent.com/129975596/236902494-14ac1d05-3dbe-4d88-be37-40cb19697e6f.png)

### Screen Layout
<img width="518" alt="Screenshot 2023-05-26 at 9 35 21 AM" src="https://github.com/cs100/final-project-skamm006-sbhan020-schau062-vsing035/assets/117537786/06626895-c7ec-4adb-aea3-6b522b9331fe">
<img width="518" alt="Screenshot 2023-05-26 at 9 35 41 AM" src="https://github.com/cs100/final-project-skamm006-sbhan020-schau062-vsing035/assets/117537786/a1f0d2b8-7324-45bd-a6a8-9d3a0695e092">
<img width="518" alt="Screenshot 2023-05-26 at 9 35 57 AM" src="https://github.com/cs100/final-project-skamm006-sbhan020-schau062-vsing035/assets/117537786/01ebd06d-7477-42e3-a5f0-6c2113017515">
<img width="518" alt="Screenshot 2023-05-26 at 9 36 10 AM" src="https://github.com/cs100/final-project-skamm006-sbhan020-schau062-vsing035/assets/117537786/2002a431-66f0-4606-8f91-3b8fb92c9c7d">
 
 ## Phase III (SOLID Principle Changes)
* For our first major change, we applied the Single Responsibility Principle (SRP). When first designing the UML diagram, we intended for the Server to have some type of implementation for taking a Customer’s order. However, we decided to take our TA’s suggestion of making a separate Order class since it is something that may be utilized by multiple classes. For instance, the Server class uses the Order class to keep track of the Customers’ orders, the Chef class uses it to make the dish, and the Server must use it to serve the Customers their respective dishes. Keeping this in mind, it did not make sense to implement the Order class within the Server class, so we developed a whole new class instead. This change was helpful in managing the tasks of each individual. The Server and Chef do not need to worry about implementing their own Order, but can now use the class while focusing on their respective tasks. In fact, now it is also easier for the Customers’ information and data to be passed between the Server and the Chef as it is a class that is accessible by the both of them.

* Our second major change was an application of the Open-Closed Principle. Initially, we had a MenuNode within the Manager class so that it could access the Menu aspects in an easier fashion. We had intended for the Manager class to only be able to update the floorplan and keep a general track of the menu. Keeping the MenuNode implementation within the Manager class meant that the Manager wasn’t doing our intended tasks. In other words, we had to modify the Menu class after implementing the Manager class, which meant that the Manager class wasn’t performing tasks solely for the Manager. This change helped make our Manager implementation open for extension, rather than for the Manager class to be responsible for the Menu attributes. With the two separate classes, each class in our program now has a specific purpose rather than trying to take on too many tasks. Also, our previous way of implementing the menu was to use Manager* myMenu = new Manager(). However, this did not make much sense considering that the menu is not a manager pointer. Now, an individual manager character holds a linked list of menuItem objects.

* For our third major change, we implemented the Dependency Inversion Principle in order to avoid changes in the subclass affecting any higher submodules. We initially planned to include functions within the Restaurant class that would set the names of the various employees in the restaurant game. However, this meant that any changes to character details would cause modifications to have to be made to the Restaurant class. To prevent this, we created an abstract class called Employee that contains a pure virtual function to set character details. Then, the respective character classes (Server, Chef, Manager) override this function with their specific character names. As a result, the higher-level modules depend on an abstraction rather than the lower-level modules.
 
 ## Final deliverable
 > All group members will give a demo to the reader during lab time. ou should schedule your demo on Calendly with the same reader who took your second scrum meeting. The reader will check the demo and the project GitHub repository and ask a few questions to all the team members. 
 > Before the demo, you should do the following:
 > * Complete the sections below (i.e. Screenshots, Installation/Usage, Testing)
 > * Plan one more sprint (that you will not necessarily complete before the end of the quarter). Your In-progress and In-testing columns should be empty (you are not doing more work currently) but your TODO column should have a full sprint plan in it as you have done before. This should include any known bugs (there should be some) or new features you would like to add. These should appear as issues/cards on your Project board.
 > * Make sure your README file and Project board are up-to-date reflecting the current status of your project (e.g. any changes that you have made during the project such as changes to your class diagram). Previous versions should still be visible through your commit history. 
 
 ## Screenshots
 > Screenshots of the input/output after running your application
 ## Installation/Usage
 > Instructions on installing and running your application
 ## Testing
 > How was your project tested/validated? If you used CI, you should have a "build passing" badge in this README.
